/************************************************************************************************************************

Programa em C para resolver os nomes de sites e exibir o respectivo endereço semelhante ao executável host do linux.

************************************************************************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <string.h>

int main(int argc, char *argv[]) {

	struct addrinfo hints, *result, *rp;

	int errorCode;
	
	memset(&hints, 0, sizeof(hints));

	hints.ai_family = AF_INET; // Somente IPv4
	hints.ai_socktype = 0; // Qualquer socket
	hints.ai_protocol = 0; // Qualquer protocolo (UDP ou TCP)
	hints.ai_flags |= AI_CANONNAME;

	errorCode = getaddrinfo(argv[1], NULL, &hints, &result); 

	if (errorCode != 0) {

		fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(errorCode));
		exit(EXIT_FAILURE);
	}

	for (rp = result; rp != NULL; rp = rp->ai_next) {
		/* 
			A biblioteca de implementação Berkley sockets faz referência a implementação genérica de um registro socketaddr.
			No linux a implementação do socket ipv4 é realizada por meio do registro sockaddr_in. Assim para obter a 
			informação do ip no formato xx.xx.xx.xx com a função inet_ntop é necessário fazer um cast do registro sockaddr 
      para sockaddr_in  e então	extrair o sin_addr para passar como parâmetro para a função inet_ntop.

		*/
		char addr[100];

		struct sockaddr_in *sock_in = (struct sockaddr_in *) rp->ai_addr;

		inet_ntop(AF_INET, &sock_in->sin_addr, addr, 100);
		//inet_ntop(AF_INET, &((struct sockaddr_in *) rp->ai_addr)->sin_addr, addr, 100);

		fprintf(stderr, "IP: %s\n PORT:%u\n PROTOCOL:%u\n CANONNAME; %s\n", addr, sock_in->sin_port, rp->ai_protocol, rp->ai_canonname);
	}

	freeaddrinfo(result);


	return 0;

}
